name: Terraform Infrastructure Provisioning

on:
  push:
    branches: [main]
    paths: ['terraform/**', '.github/workflows/infra.yml', 'src/**', 'kubernetes/**', '!kubernetes/15-keyvault-secret-provider.yaml', 'scripts/**', 'Dockerfile', 'docker-compose.yml', 'package*.json']
  pull_request:
    branches: [main] 
    paths: ['terraform/**', '.github/workflows/infra.yml', 'src/**', 'kubernetes/**', '!kubernetes/15-keyvault-secret-provider.yaml', 'scripts/**', 'Dockerfile', 'docker-compose.yml', 'package*.json']
  workflow_dispatch:

env:
  TERRAFORM_VERSION: '1.6.0'
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

jobs:
  prepare-config:
    name: 'Prepare Terraform Configuration'
    runs-on: ubuntu-latest
    steps:
      - name: Create terraform configuration
        run: |
          cat > terraform.tfvars << EOF
          project_name = "${{ secrets.TF_PROJECT_NAME }}"
          location     = "${{ secrets.TF_LOCATION }}"
          acr_name = "${{ secrets.TF_ACR_NAME }}"
          aks_cluster_name = "${{ secrets.TF_AKS_CLUSTER_NAME }}"
          dns_zone_name = "${{ secrets.TF_DNS_ZONE_NAME }}"
          argocd_namespace = "${{ secrets.TF_ARGOCD_NAMESPACE }}"
          github_repo_url  = "${{ secrets.TF_GITHUB_REPO_URL }}"

          admin_object_id = "${{ secrets.TF_ADMIN_OBJECT_ID }}"
          tags = {
            Project   = "EasyShop"
            ManagedBy = "Terraform"
            Owner     = "${{ secrets.TF_OWNER }}"
          }
          EOF
          
          cat > backend.conf << EOF
          resource_group_name  = "${{ secrets.TF_STATE_RESOURCE_GROUP }}"
          storage_account_name = "${{ secrets.TF_STATE_STORAGE_ACCOUNT }}"
          container_name       = "${{ secrets.TF_STATE_CONTAINER }}"
          key                  = "${{ secrets.TF_STATE_KEY }}"
          EOF

      - name: Upload configuration artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-config
          path: |
            terraform.tfvars
            backend.conf
          retention-days: 5

  plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    needs: prepare-config
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: terraform-config
          path: terraform/
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Cache Terraform
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            terraform/.terraform
            terraform/.terraform.lock.hcl
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/.terraform.lock.hcl', 'terraform/**/*.tf') }}
          restore-keys: ${{ runner.os }}-terraform-
      - name: Configure Terraform cache & init
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc
          terraform init -backend-config="backend.conf" -reconfigure
          terraform validate
      - name: Terraform Plan
        run: terraform plan -var-file="terraform.tfvars" -out=tfplan -no-color
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5
      - name: Upload cache artifact  
        uses: actions/upload-artifact@v4
        with:
          name: terraform-cache
          path: ~/.terraform.d/plugin-cache
          retention-days: 5
  
  apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    needs: [prepare-config, plan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    defaults:
      run:
        working-directory: terraform
    outputs:
      key_vault_name: ${{ steps.export.outputs.key_vault_name }}
      managed_identity_client_id: ${{ steps.export.outputs.managed_identity_client_id }}
      tenant_id: ${{ steps.export.outputs.tenant_id }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: terraform-config
          path: terraform/
      - uses: actions/download-artifact@v4
        with:
          name: terraform-cache
          path: ~/.terraform.d/plugin-cache
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
      - name: Configure cache & apply
        run: |
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc
          terraform init -backend-config="backend.conf" -reconfigure
          
      - name: üîç Pre-Apply Validation
        run: |
          echo "üîç Validating Azure resources before apply..."
          
          # Check if resource group exists and its status
          if az group exists --name ${{ secrets.TF_PROJECT_NAME }}-rg; then
            RG_STATUS=$(az group show --name ${{ secrets.TF_PROJECT_NAME }}-rg --query "properties.provisioningState" -o tsv)
            echo "üìã Resource group exists with status: $RG_STATUS"
            
            if [[ "$RG_STATUS" == "Deleting" ]]; then
              echo "‚ùå Resource group is being deleted. Cannot proceed with apply."
              echo "‚è≥ Please wait for deletion to complete and re-run the workflow."
              exit 1
            fi
          else
            echo "‚úÖ Resource group does not exist - ready for creation"
          fi
          
          # Validate Terraform configuration
          terraform validate
          echo "‚úÖ Terraform configuration is valid"
      - uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/
      - name: Terraform Apply & Export
        id: export
        run: |
          # Check if resource group is being deleted and wait if necessary
          echo "üîç Checking resource group status..."
          RG_STATUS=$(az group show --name ${{ secrets.TF_PROJECT_NAME }}-rg --query "properties.provisioningState" -o tsv 2>/dev/null || echo "NotFound")
          echo "üìã Resource group status: $RG_STATUS"
          
          if [[ "$RG_STATUS" == "Deleting" ]]; then
            echo "‚ö†Ô∏è Resource group is being deleted. Waiting for completion..."
            
            # Wait for deletion to complete (max 10 minutes)
            for i in {1..60}; do
              sleep 10
              RG_EXISTS=$(az group exists --name ${{ secrets.TF_PROJECT_NAME }}-rg)
              if [[ "$RG_EXISTS" == "false" ]]; then
                echo "‚úÖ Resource group deletion completed"
                break
              fi
              echo "‚è≥ Still waiting for deletion... ($i/60)"
            done
            
            # Refresh Terraform state after deletion
            echo "üîÑ Refreshing Terraform state..."
            terraform refresh -var-file="terraform.tfvars" || echo "State refresh completed"
          fi
          
          # Apply with retry logic for transient Azure issues
          echo "üöÄ Applying Terraform configuration..."
          RETRY_COUNT=0
          MAX_RETRIES=3
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if terraform apply tfplan -no-color; then
              echo "‚úÖ Terraform apply successful!"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Terraform apply failed. Retrying in 30 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 30
                
                # Refresh state before retry
                terraform refresh -var-file="terraform.tfvars" || echo "State refresh completed"
              else
                echo "‚ùå Terraform apply failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Export outputs
          echo "üì§ Exporting Terraform outputs..."
          echo "key_vault_name=$(terraform output -raw key_vault_name 2>/dev/null || echo 'not-created')" >> $GITHUB_OUTPUT
          echo "managed_identity_client_id=$(terraform output -raw managed_identity_client_id 2>/dev/null || echo 'not-created')" >> $GITHUB_OUTPUT
          echo "tenant_id=$(terraform output -raw tenant_id 2>/dev/null || echo 'not-created')" >> $GITHUB_OUTPUT

  update-k8s-manifests:
    name: 'Update Kubernetes Manifests'
    runs-on: ubuntu-latest
    needs: apply
    if: success()
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Update & commit manifests
        run: |
          sed -i 's/${MANAGED_IDENTITY_CLIENT_ID}/${{ needs.apply.outputs.managed_identity_client_id }}/g' kubernetes/15-keyvault-secret-provider.yaml
          sed -i 's/${TENANT_ID}/${{ needs.apply.outputs.tenant_id }}/g' kubernetes/15-keyvault-secret-provider.yaml
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add kubernetes/15-keyvault-secret-provider.yaml
          git diff --staged --quiet || git commit -m "Update SecretProviderClass with Terraform outputs [skip ci]"
          git push

  deploy-argocd:
    name: 'Deploy ArgoCD to AKS'
    runs-on: ubuntu-latest
    needs: apply
    if: success()
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Azure CLI and kubectl
        run: |
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
      
      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.TF_PROJECT_NAME }}-rg \
            --name ${{ secrets.TF_AKS_CLUSTER_NAME }} \
            --overwrite-existing

      # üöÄ ADD THIS STEP RIGHT HERE - BEFORE ArgoCD deployment
      - name: Install cert-manager
        run: |
          echo "üì¶ Installing cert-manager CRDs and components..."
          
          # Install cert-manager
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
          
          # Wait for cert-manager to be ready
          echo "‚è≥ Waiting for cert-manager to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
          
          # Verify CRDs are available
          echo "‚úÖ Verifying cert-manager CRDs..."
          kubectl get crd certificates.cert-manager.io
          kubectl get crd clusterissuers.cert-manager.io
          
          echo "‚úÖ cert-manager installed successfully!"
      
      - name: Deploy ArgoCD
        run: |
          # Create namespace
          kubectl create namespace ${{ secrets.TF_ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Add Helm repo
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          
          # Deploy ArgoCD
          helm upgrade --install argocd argo/argo-cd \
            --namespace ${{ secrets.TF_ARGOCD_NAMESPACE }} \
            --version 5.51.4 \
            --set server.service.type=LoadBalancer \
            --set dex.enabled=false \
            --set notifications.enabled=false \
            --set applicationSet.enabled=false \
            --wait --timeout=10m
          
          echo "‚úÖ ArgoCD deployed successfully!"
      
      - name: Deploy ArgoCD Image Updater
        run: |
          # Create ACR secret
          kubectl create secret docker-registry acr-secret \
            --namespace=${{ secrets.TF_ARGOCD_NAMESPACE }} \
            --docker-server=${{ secrets.TF_ACR_NAME }}.azurecr.io \
            --docker-username=$(az acr credential show -n ${{ secrets.TF_ACR_NAME }} --query username -o tsv) \
            --docker-password=$(az acr credential show -n ${{ secrets.TF_ACR_NAME }} --query passwords[0].value -o tsv) \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy ArgoCD Image Updater
          helm upgrade --install argocd-image-updater argo/argocd-image-updater \
            --namespace ${{ secrets.TF_ARGOCD_NAMESPACE }} \
            --version 0.9.1 \
            --set config.registries[0].name=acr \
            --set config.registries[0].api_url=https://${{ secrets.TF_ACR_NAME }}.azurecr.io \
            --set config.registries[0].prefix=${{ secrets.TF_ACR_NAME }}.azurecr.io \
            --set config.registries[0].credentials="pullsecret:${{ secrets.TF_ARGOCD_NAMESPACE }}/acr-secret" \
            --set config.git.requireAuth=false \
            --wait --timeout=5m
          
          echo "‚úÖ ArgoCD Image Updater deployed successfully!"

  trigger-deploy:
    name: 'Trigger Application Deployment'
    runs-on: ubuntu-latest
    needs: [apply, update-k8s-manifests, deploy-argocd]  # cert-manager is installed in deploy-argocd job
    if: success()
    steps:
      - uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          event-type: deploy-applications
          client-payload: |
            {
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}",
              "key_vault_name": "${{ needs.apply.outputs.key_vault_name }}",
              "managed_identity_client_id": "${{ needs.apply.outputs.managed_identity_client_id }}",
              "tenant_id": "${{ needs.apply.outputs.tenant_id }}"
            }
              
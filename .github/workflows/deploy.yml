name: EasyShop Application Deployment

on:
  workflow_dispatch:
  repository_dispatch:
    types: [deploy-applications]
  workflow_run:
    workflows: ["Terraform Infrastructure Provisioning"]
    types: [completed]
    branches: [main]

env:
  REGISTRY: ${{ secrets.TF_ACR_NAME }}.azurecr.io
  IMAGE_NAME: easyshop
  AKS_CLUSTER_NAME: ${{ secrets.TF_AKS_CLUSTER_NAME }}
  RESOURCE_GROUP: ${{ secrets.TF_PROJECT_NAME }}-rg
  NAMESPACE: easyshop

jobs:
  deploy-application:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'repository_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    
    steps:
    - name: ğŸš€ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Azure Login
      uses: azure/login@v2
      with:
        creds: |
          {
            "clientId": "${{ secrets.ARM_CLIENT_ID }}",
            "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.ARM_TENANT_ID }}"
          }

    - name: ğŸ¯ Generate SHA Version
      id: version
      run: |
        VERSION="${GITHUB_SHA::8}"
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "ğŸ“¦ Using SHA version: $VERSION"

    - name: ğŸ‹ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        driver-opts: |
          image=moby/buildkit:latest
        use: true

    - name: ğŸ”‘ Login to ACR
      run: |
        az acr login --name ${{ secrets.TF_ACR_NAME }}

    - name: ğŸ—ï¸ Build and Push with Caching
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        build-args: |
          GIT_SHA=${{ env.VERSION }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache,mode=max
        outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push=true

    - name: ğŸ“Œ Get Image Reference
      run: |
        IMAGE_DIGEST="${{ steps.build.outputs.digest }}"
        
        if [[ -n "$IMAGE_DIGEST" ]]; then
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          echo "âœ… Got digest from build: $IMAGE_DIGEST"
        else
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}"
          echo "âš ï¸ No digest from build, using tag: $IMAGE_WITH_DIGEST"
        fi
        
        echo "IMAGE_WITH_DIGEST=$IMAGE_WITH_DIGEST" >> $GITHUB_ENV
        echo "ğŸ“Œ Final image: $IMAGE_WITH_DIGEST"

    - name: âš™ï¸ Setup Kubernetes Tools
      run: |
        echo "ğŸ”‘ Getting AKS credentials..."
        
        # Hard-code values to avoid masking issues
        RESOURCE_GROUP="easyshop-rg"
        AKS_CLUSTER="easyshop-aks"
        
        az aks get-credentials \
          --resource-group "$RESOURCE_GROUP" \
          --name "$AKS_CLUSTER" \
          --overwrite-existing
        
        echo "ğŸ“¦ Installing kustomize..."
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/

    # OPTIMIZED: Single step for Key Vault setup with proper error handling
    # In .github/workflows/deploy.yml - Replace the entire Configure Key Vault Access step

    - name: ğŸ”§ Configure Key Vault Access and SecretProviderClass
      run: |
        set -e
        echo "ğŸ”§ Configuring Key Vault CSI Driver..."
        
        # Hard-code values to avoid issues
        RESOURCE_GROUP="easyshop-rg"
        AKS_CLUSTER="easyshop-aks"
        
        # Get Key Vault and Tenant
        KEY_VAULT_NAME=$(az keyvault list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[?starts_with(name, 'easyshop-kv-')].name | [0]" \
          -o tsv)
        
        TENANT_ID=$(az account show --query tenantId -o tsv)
        
        # CRITICAL: Get the CORRECT identity from the node resource group
        # NOT from the addon profile!
        NODE_RG=$(az aks show -g "$RESOURCE_GROUP" -n "$AKS_CLUSTER" --query nodeResourceGroup -o tsv)
        
        # Get the azurekeyvaultsecretsprovider identity - this is what's actually on the nodes
        ADDON_CLIENT_ID=$(az identity show \
          --resource-group "$NODE_RG" \
          --name "azurekeyvaultsecretsprovider-${AKS_CLUSTER}" \
          --query clientId -o tsv)
        
        ADDON_OBJECT_ID=$(az identity show \
          --resource-group "$NODE_RG" \
          --name "azurekeyvaultsecretsprovider-${AKS_CLUSTER}" \
          --query principalId -o tsv)
        
        echo "ğŸ“‹ Configuration:"
        echo "  KEY_VAULT_NAME: $KEY_VAULT_NAME"
        echo "  TENANT_ID: $TENANT_ID"
        echo "  ADDON_CLIENT_ID: $ADDON_CLIENT_ID (from node RG)"
        echo "  ADDON_OBJECT_ID: $ADDON_OBJECT_ID (from node RG)"
        
        # Set Key Vault access policy
        echo "ğŸ” Setting Key Vault access policy..."
        az keyvault set-policy \
          --name "$KEY_VAULT_NAME" \
          --object-id "$ADDON_OBJECT_ID" \
          --secret-permissions get list \
          --output table
        
        # Export for next steps
        echo "KEY_VAULT_NAME=$KEY_VAULT_NAME" >> $GITHUB_ENV
        echo "TENANT_ID=$TENANT_ID" >> $GITHUB_ENV
        echo "ADDON_CLIENT_ID=$ADDON_CLIENT_ID" >> $GITHUB_ENV
        
        sleep 30

    # Add this step BEFORE the Blue-Green Deployment step in .github/workflows/deploy.yml
    #=======================================================================================

    - name: ğŸ” Diagnose SecretProviderClass Configuration
      run: |
        echo "=========================================="
        echo "ğŸ” SECRETPROVIDERCLASS DIAGNOSTIC REPORT"
        echo "=========================================="
        
        # Step 1: Check what values we're trying to use
        echo "1ï¸âƒ£ FETCHING AZURE RESOURCES..."
        echo "------------------------------------------"
        
        # Get Key Vault
        echo "Searching for Key Vaults in resource group ${{ env.RESOURCE_GROUP }}..."
        KV_LIST=$(az keyvault list --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o json)
        echo "Key Vaults found: $KV_LIST"
        
        KEY_VAULT_NAME=$(az keyvault list \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query "[?starts_with(name, '${{ secrets.TF_PROJECT_NAME }}-kv-')].name | [0]" \
          -o tsv)
        
        if [[ -z "$KEY_VAULT_NAME" || "$KEY_VAULT_NAME" == "null" ]]; then
          echo "âŒ CRITICAL: No Key Vault found!"
          echo "Looking for any Key Vault in resource group..."
          az keyvault list --resource-group ${{ env.RESOURCE_GROUP }} -o table
        else
          echo "âœ… Key Vault found: $KEY_VAULT_NAME"
        fi
        
        # Get Tenant ID
        TENANT_ID=$(az account show --query tenantId -o tsv)
        if [[ -z "$TENANT_ID" ]]; then
          echo "âŒ CRITICAL: Cannot get Tenant ID!"
        else
          echo "âœ… Tenant ID: $TENANT_ID"
        fi
        
        # Get AKS addon identity
        echo ""
        echo "Getting AKS addon identity..."
        ADDON_JSON=$(az aks show \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --query "addonProfiles.azureKeyvaultSecretsProvider" \
          -o json)
        
        echo "Addon configuration: $ADDON_JSON"
        
        ADDON_CLIENT_ID=$(echo "$ADDON_JSON" | jq -r '.identity.clientId // empty')
        ADDON_OBJECT_ID=$(echo "$ADDON_JSON" | jq -r '.identity.objectId // empty')
        
        if [[ -z "$ADDON_CLIENT_ID" ]]; then
          echo "âŒ CRITICAL: Cannot get addon Client ID!"
          echo "Trying alternative query..."
          ADDON_CLIENT_ID=$(az aks show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --query "addonProfiles.azureKeyvaultSecretsProvider.identity.clientId" \
            -o tsv)
          echo "Alternative result: $ADDON_CLIENT_ID"
        else
          echo "âœ… Addon Client ID: $ADDON_CLIENT_ID"
        fi
        
        if [[ -z "$ADDON_OBJECT_ID" ]]; then
          echo "âŒ WARNING: Cannot get addon Object ID (needed for Key Vault policy)"
        else
          echo "âœ… Addon Object ID: $ADDON_OBJECT_ID"
        fi
        
        # Step 2: Check the source file
        echo ""
        echo "2ï¸âƒ£ CHECKING SOURCE FILE..."
        echo "------------------------------------------"
        cd kubernetes
        
        if [[ ! -f "15-keyvault-secret-provider.yaml" ]]; then
          echo "âŒ CRITICAL: File 15-keyvault-secret-provider.yaml not found!"
          echo "Files in directory:"
          ls -la *.yaml
        else
          echo "âœ… File exists"
          echo "File content (first 30 lines):"
          head -30 15-keyvault-secret-provider.yaml
          
          echo ""
          echo "Checking for placeholders..."
          grep -n "PLACEHOLDER" 15-keyvault-secret-provider.yaml || echo "No PLACEHOLDER found"
          
          echo ""
          echo "Current values in file:"
          grep -E "keyvaultName:|tenantId:|userAssignedIdentityClientID:" 15-keyvault-secret-provider.yaml
        fi
        
        # Step 3: Test substitution
        echo ""
        echo "3ï¸âƒ£ TESTING SUBSTITUTION..."
        echo "------------------------------------------"
        
        if [[ -f "15-keyvault-secret-provider.yaml" ]]; then
          cp 15-keyvault-secret-provider.yaml test-substitution.yaml
          
          echo "Before substitution:"
          grep -E "keyvaultName:|tenantId:|userAssignedIdentityClientID:" test-substitution.yaml
          
          # Test each substitution individually
          echo ""
          echo "Testing keyvaultName substitution..."
          sed -i "s/PLACEHOLDER_KEYVAULT_NAME/$KEY_VAULT_NAME/g" test-substitution.yaml
          grep "keyvaultName:" test-substitution.yaml
          
          echo ""
          echo "Testing tenantId substitution..."
          sed -i "s/PLACEHOLDER_TENANT_ID/$TENANT_ID/g" test-substitution.yaml
          grep "tenantId:" test-substitution.yaml
          
          echo ""
          echo "Testing clientId substitution..."
          sed -i "s/PLACEHOLDER_CLIENT_ID/$ADDON_CLIENT_ID/g" test-substitution.yaml
          grep "userAssignedIdentityClientID:" test-substitution.yaml
          
          echo ""
          echo "After all substitutions:"
          grep -E "keyvaultName:|tenantId:|userAssignedIdentityClientID:" test-substitution.yaml
          
          echo ""
          echo "Checking if any placeholders remain:"
          grep "PLACEHOLDER" test-substitution.yaml && echo "âŒ PLACEHOLDERS STILL EXIST!" || echo "âœ… All placeholders replaced"
          
          rm test-substitution.yaml
        fi
        
        # Step 4: Check kustomization.yaml
        echo ""
        echo "4ï¸âƒ£ CHECKING KUSTOMIZATION..."
        echo "------------------------------------------"
        
        if [[ -f "kustomization.yaml" ]]; then
          echo "Checking if SecretProviderClass is in resources:"
          grep "15-keyvault-secret-provider.yaml" kustomization.yaml && echo "âœ… Found in kustomization" || echo "âŒ NOT in kustomization!"
        else
          echo "âŒ kustomization.yaml not found!"
        fi
        
        # Step 5: Check what's currently in the cluster
        echo ""
        echo "5ï¸âƒ£ CHECKING CLUSTER STATE..."
        echo "------------------------------------------"
        
        echo "Checking if SecretProviderClass exists in cluster:"
        kubectl get secretproviderclass -n ${{ env.NAMESPACE }} -o name || echo "No SecretProviderClass found"
        
        if kubectl get secretproviderclass easyshop-keyvault-secrets -n ${{ env.NAMESPACE }} &>/dev/null; then
          echo "SecretProviderClass exists, checking its configuration:"
          CURRENT_KV=$(kubectl get secretproviderclass easyshop-keyvault-secrets -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.parameters.keyvaultName}')
          CURRENT_TENANT=$(kubectl get secretproviderclass easyshop-keyvault-secrets -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.parameters.tenantId}')
          CURRENT_CLIENT=$(kubectl get secretproviderclass easyshop-keyvault-secrets -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.parameters.userAssignedIdentityClientID}')
          
          echo "Current keyvaultName: '$CURRENT_KV'"
          echo "Current tenantId: '$CURRENT_TENANT'"
          echo "Current clientId: '$CURRENT_CLIENT'"
          
          if [[ -z "$CURRENT_KV" || "$CURRENT_KV" == "PLACEHOLDER_KEYVAULT_NAME" ]]; then
            echo "âŒ keyvaultName is not set or still has placeholder!"
          fi
          if [[ -z "$CURRENT_TENANT" || "$CURRENT_TENANT" == "PLACEHOLDER_TENANT_ID" ]]; then
            echo "âŒ tenantId is not set or still has placeholder!"
          fi
          if [[ -z "$CURRENT_CLIENT" || "$CURRENT_CLIENT" == "PLACEHOLDER_CLIENT_ID" ]]; then
            echo "âŒ userAssignedIdentityClientID is not set or still has placeholder!"
          fi
        fi
        
        # Step 6: Summary
        echo ""
        echo "6ï¸âƒ£ DIAGNOSTIC SUMMARY..."
        echo "------------------------------------------"
        
        ERROR_COUNT=0
        
        if [[ -z "$KEY_VAULT_NAME" || "$KEY_VAULT_NAME" == "null" ]]; then
          echo "âŒ FAIL: Key Vault name cannot be determined"
          ((ERROR_COUNT++))
        else
          echo "âœ… PASS: Key Vault name = $KEY_VAULT_NAME"
        fi
        
        if [[ -z "$TENANT_ID" ]]; then
          echo "âŒ FAIL: Tenant ID cannot be determined"
          ((ERROR_COUNT++))
        else
          echo "âœ… PASS: Tenant ID = $TENANT_ID"
        fi
        
        if [[ -z "$ADDON_CLIENT_ID" ]]; then
          echo "âŒ FAIL: Addon Client ID cannot be determined"
          ((ERROR_COUNT++))
        else
          echo "âœ… PASS: Addon Client ID = $ADDON_CLIENT_ID"
        fi
        
        if [[ ! -f "15-keyvault-secret-provider.yaml" ]]; then
          echo "âŒ FAIL: SecretProviderClass file missing"
          ((ERROR_COUNT++))
        else
          echo "âœ… PASS: SecretProviderClass file exists"
        fi
        
        echo ""
        if [[ $ERROR_COUNT -gt 0 ]]; then
          echo "âŒ DIAGNOSTIC FAILED: $ERROR_COUNT critical issues found"
          echo "Cannot proceed with deployment until these are fixed."
          exit 1
        else
          echo "âœ… All diagnostic checks passed"
          echo "Proceeding with deployment..."
        fi
        
        # Export values for next step
        echo "KEY_VAULT_NAME=$KEY_VAULT_NAME" >> $GITHUB_ENV
        echo "TENANT_ID=$TENANT_ID" >> $GITHUB_ENV
        echo "ADDON_CLIENT_ID=$ADDON_CLIENT_ID" >> $GITHUB_ENV
        
        echo "=========================================="
        echo "END OF DIAGNOSTIC REPORT"
        echo "=========================================="
  
#=============================================================================================
    # OPTIMIZED: Simplified deployment with better error handling
    - name: ğŸš€ Blue-Green Deployment
      run: |
        set -e
        echo "ğŸš€ Starting Blue-Green Deployment..."
        
        # Create namespace
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        cd kubernetes
        
        # CRITICAL: Verify we have the current values
        if [[ -z "$KEY_VAULT_NAME" ]]; then
          echo "âŒ KEY_VAULT_NAME not set from previous step!"
          exit 1
        fi
        
        echo "ğŸ“ Updating SecretProviderClass with actual values..."
        echo "Using values from environment:"
        echo "  KEY_VAULT_NAME: $KEY_VAULT_NAME"
        echo "  TENANT_ID: $TENANT_ID"
        echo "  ADDON_CLIENT_ID: $ADDON_CLIENT_ID"
        
        # IMPORTANT: Replace ALL occurrences, including any hardcoded ones
        # First, remove any comments that might have old values
        sed -i '/# Your actual/d' 15-keyvault-secret-provider.yaml
        sed -i '/# Use your actual/d' 15-keyvault-secret-provider.yaml
        
        # Now do the replacements
        sed -i "s/PLACEHOLDER_KEYVAULT_NAME/${KEY_VAULT_NAME}/g" 15-keyvault-secret-provider.yaml
        sed -i "s/easyshop-kv-[0-9]*/${KEY_VAULT_NAME}/g" 15-keyvault-secret-provider.yaml  # Replace any old hardcoded names
        sed -i "s/PLACEHOLDER_TENANT_ID/${TENANT_ID}/g" 15-keyvault-secret-provider.yaml
        
        
        # Verify the substitution worked
        echo "ğŸ“‹ Verifying SecretProviderClass configuration:"
        echo "Actual values in SecretProviderClass:"
        grep -E "keyvaultName:|tenantId:|userAssignedIdentityClientID:" 15-keyvault-secret-provider.yaml
        
        # Check if any placeholders remain
        if grep -q "PLACEHOLDER" 15-keyvault-secret-provider.yaml; then
          echo "âŒ Placeholders still exist!"
          cat 15-keyvault-secret-provider.yaml
          exit 1
        fi
        
        # Check for old Key Vault names
        if grep -q "easyshop-kv-09032127" 15-keyvault-secret-provider.yaml; then
          echo "âŒ Old Key Vault name still exists!"
          cat 15-keyvault-secret-provider.yaml
          exit 1
        fi
        
        # Update image
        echo "ğŸ“ Updating image to: ${{ env.IMAGE_WITH_DIGEST }}"
        kustomize edit set image easyshop=${{ env.IMAGE_WITH_DIGEST }}
        
        # Build manifests
        echo "ğŸ”¨ Building Kubernetes manifests..."
        kustomize build . > /tmp/manifests.yaml
        
        # CRITICAL: Verify keyvaultName is properly set in manifests
        echo "ğŸ” Final verification of built manifests..."
        if ! grep -q "keyvaultName: ${KEY_VAULT_NAME}" /tmp/manifests.yaml; then
          echo "âŒ keyvaultName not properly set in built manifests!"
          echo "Looking for SecretProviderClass in manifests:"
          grep -A 20 "kind: SecretProviderClass" /tmp/manifests.yaml
          exit 1
        fi
        
        echo "âœ… keyvaultName is properly set in manifests"
        
        # Apply manifests
        echo "ğŸ“¦ Applying manifests to cluster..."
        kubectl apply -f /tmp/manifests.yaml
        
        # Rest of deployment logic...

    - name: ğŸ” Verify Deployment
      if: success()
      run: |
        echo "ğŸ” Final deployment verification..."
        
        # Check all components
        echo "ğŸ“¦ Pods:"
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        echo "ğŸŒ Services:"
        kubectl get svc -n ${{ env.NAMESPACE }}
        
        echo "ğŸ”— Ingress:"
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        # Get application URL
        INGRESS_HOST=$(kubectl get ingress easyshop-ingress -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "${{ secrets.TF_DNS_ZONE_NAME }}")
        
        echo ""
        echo "ğŸ‰ Deployment Complete!"
        echo "=================================="
        echo "ğŸ·ï¸ Version: ${{ env.VERSION }}"
        echo "ğŸ‹ Image: ${{ env.IMAGE_WITH_DIGEST }}"
        echo "ğŸŒ URL: https://$INGRESS_HOST"
        echo "=================================="
        
name: EasyShop Application Deployment

on:
  workflow_dispatch:
  repository_dispatch:
    types: [deploy-applications]
  workflow_run:
    workflows: ["Terraform Infrastructure Provisioning"]
    types: [completed]
    branches: [main]

env:
  REGISTRY: ${{ secrets.TF_ACR_NAME }}.azurecr.io
  IMAGE_NAME: easyshop
  AKS_CLUSTER_NAME: ${{ secrets.TF_AKS_CLUSTER_NAME }}
  RESOURCE_GROUP: ${{ secrets.TF_PROJECT_NAME }}-rg
  NAMESPACE: easyshop

jobs:
  deploy-application:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'repository_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    
    steps:
    - name: 🚀 Checkout Repository
      uses: actions/checkout@v4

    - name: 🔐 Azure Login
      uses: azure/login@v2
      with:
        creds: |
          {
            "clientId": "${{ secrets.ARM_CLIENT_ID }}",
            "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.ARM_TENANT_ID }}"
          }

    - name: 🎯 Generate SHA Version
      id: version
      run: |
        VERSION="${GITHUB_SHA::8}"
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "📦 Using SHA version: $VERSION"

    # ✅ FIXED: Set up Docker Buildx with container driver that supports cache
    - name: 🐋 Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        driver-opts: |
          image=moby/buildkit:latest
        use: true

    # ✅ FIXED: Use Azure CLI for ACR login (more reliable than docker-login action)
    - name: 🔑 Login to ACR
      run: |
        az acr login --name ${{ secrets.TF_ACR_NAME }}

    # ✅ FIXED: Build and Push with ACR registry cache (more reliable than GHA cache for ACR)
    # Modify your existing build step to capture the digest:
    # Modify your existing build step to capture the digest:
    - name: 🏗️ Build and Push with Caching
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        build-args: |
          GIT_SHA=${{ env.VERSION }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache,mode=max
        outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push=true

    # Then extract the digest from the build output:
    - name: 📌 Get Image Digest from Build
      run: |
        # The build step outputs metadata including the digest
        IMAGE_DIGEST="${{ steps.build.outputs.digest }}"
        
        if [[ -n "$IMAGE_DIGEST" ]]; then
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          echo "✅ Got digest from build: $IMAGE_DIGEST"
        else
          # Fallback: extract from build metadata
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}"
          echo "⚠️ No digest from build, using tag: $IMAGE_WITH_DIGEST"
        fi
        
        echo "IMAGE_WITH_DIGEST=$IMAGE_WITH_DIGEST" >> $GITHUB_ENV
        echo "📌 Final image: $IMAGE_WITH_DIGEST"

    - name: ⚙️ Connect to AKS & Install Kustomize
      run: |
        echo "🔑 Getting AKS credentials..."
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
        
        echo "📦 Installing kustomize..."
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/
#*************************************************************************
    # ADD THIS NEW DEBUG STEP HERE - BEFORE THE DEPLOYMENT STEP:
    - name: 🔍 Debug SecretProviderClass Configuration
      run: |
        echo "🔍 Checking SecretProviderClass configuration..."
        
        # Show the actual SecretProviderClass that was applied
        echo "📋 SecretProviderClass YAML:"
        kubectl get secretproviderclass easyshop-keyvault-secrets -n easyshop -o yaml 2>/dev/null || echo "SecretProviderClass not found"
        
        # Check if CSI driver is installed
        echo ""
        echo "🔍 CSI Secret Store driver pods:"
        kubectl get pods -n kube-system | grep csi || echo "No CSI pods found"
        
        # Check events for CSI-related errors
        echo ""
        echo "🔍 Recent events in namespace:"
        kubectl get events -n easyshop --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo "No events found"
        
        # Check if the managed identity exists and has correct permissions
        echo ""
        echo "🔍 Managed identity in SecretProviderClass:"
        kubectl get secretproviderclass easyshop-keyvault-secrets -n easyshop -o jsonpath='{.spec.parameters.userAssignedIdentityClientID}' 2>/dev/null || echo "Could not get managed identity ID"
        
        # Check AKS addons
        echo ""
        echo "🔍 AKS addons status:"
        az aks show --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }} --query addonProfiles

#*************************************************************************

#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    # ADD THIS STEP AFTER THE DEBUG STEP AND BEFORE DEPLOYMENT:
    - name: 🔧 Fix CSI Secret Store Driver Registration
      run: |
        echo "🔧 Fixing CSI Secret Store driver registration..."
        
        # Restart the CSI driver daemonset to re-register it
        kubectl rollout restart daemonset/aks-secrets-store-csi-driver -n kube-system
        
        # Wait for the daemonset to be ready
        echo "⏳ Waiting for CSI driver to restart..."
        kubectl rollout status daemonset/aks-secrets-store-csi-driver -n kube-system --timeout=120s
        
        # Verify CSI driver is now registered
        echo "🔍 Checking if CSI driver is now registered..."
        kubectl get csidriver secrets-store.csi.x-k8s.io || {
          echo "❌ CSI driver still not registered, trying manual installation..."
          
          # Force reinstall the CSI driver
          kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/provider-azure-installer.yaml
          
          # Wait a bit for registration
          sleep 30
          
          # Check again
          kubectl get csidriver secrets-store.csi.x-k8s.io || {
            echo "❌ CSI driver registration failed completely"
            exit 1
          }
        }
        
        echo "✅ CSI driver is now registered!"
        
        # Also restart any existing pods that were stuck
        echo "🔄 Restarting stuck pods..."
        kubectl delete pods -n easyshop --field-selector=status.phase=Pending --force --grace-period=0 || true
        kubectl delete pods -n easyshop -l app=easyshop-blue --force --grace-period=0 || true
        kubectl delete pods -n easyshop -l app=easyshop-green --force --grace-period=0 || true
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#====================================================================
#====================================================================
    - name: 🚀 Blue-Green Deployment - Final Fix
      run: |
        set -e
        
        echo "🚀 Starting Blue-Green Deployment..."
        
        # Create namespace
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        cd kubernetes
        
        # Show available files (for debugging)
        echo "📋 Available files:"
        ls -1 *.yaml *.yml | sort
        
        # Show current kustomization content
        echo ""
        echo "📝 Current kustomization.yaml:"
        cat kustomization.yaml
        
        # Update the image
        echo ""
        echo "📝 Updating image to: ${{ env.IMAGE_WITH_DIGEST }}"
        kustomize edit set image easyshop=${{ env.IMAGE_WITH_DIGEST }}
        
        # Show the updated images section
        echo ""
        echo "📝 Updated images section:"
        echo "========================="
        grep -A 10 "^images:" kustomization.yaml || echo "No images section found"
        
        # Test kustomize build
        echo ""
        echo "🔍 Testing kustomize build:"
        echo "=========================="
        
        # Capture both stdout and stderr
        if kustomize build . > /tmp/manifests.yaml 2> /tmp/kustomize_stderr.txt; then
          # Success case
          RESOURCE_COUNT=$(grep -c "^kind:" /tmp/manifests.yaml 2>/dev/null || echo "0")
          echo "✅ Kustomize build successful!"
          echo "📊 Generated resources: $RESOURCE_COUNT"
          
          if [ "$RESOURCE_COUNT" -eq 0 ]; then
            echo ""
            echo "❌ No resources generated (empty output)!"
            echo "📋 Manifest file size: $(wc -c < /tmp/manifests.yaml) bytes"
            echo "📋 First 200 characters of output:"
            head -c 200 /tmp/manifests.yaml
            echo ""
            echo "📋 Stderr output:"
            cat /tmp/kustomize_stderr.txt
            exit 1
          fi
          
          echo ""
          echo "🔍 Resource types generated:"
          grep "^kind:" /tmp/manifests.yaml | sort | uniq -c
          
          echo ""
          echo "🐋 Image references in generated manifests:"
          grep -n "image:" /tmp/manifests.yaml | head -10
          
        else
          # Error case
          echo "❌ Kustomize build failed!"
          echo ""
          echo "📋 Error output (stderr):"
          cat /tmp/kustomize_stderr.txt
          echo ""
          echo "📋 Partial output (stdout):"
          head -50 /tmp/manifests.yaml 2>/dev/null || echo "No stdout output"
          echo ""
          echo "🔧 Debugging info:"
          echo "   Current directory: $(pwd)"
          echo "   Kustomize version: $(kustomize version --short 2>/dev/null || echo 'unknown')"
          exit 1
        fi
        
        # If we get here, kustomize worked! Continue with deployment...
        
        # Determine current active deployment
        CURRENT_DEPLOYMENT=$(kubectl get svc easyshop-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.app}' 2>/dev/null || echo "easyshop-blue")
        
        # Determine target deployment
        if [ "$CURRENT_DEPLOYMENT" = "easyshop-blue" ]; then
          TARGET_DEPLOYMENT="easyshop-green"
          echo ""
          echo "🔄 Current active: BLUE → Deploying to: GREEN"
        else
          TARGET_DEPLOYMENT="easyshop-blue"
          echo ""
          echo "🔄 Current active: GREEN → Deploying to: BLUE"
        fi
        
        # Apply all manifests
        echo ""
        echo "📦 Applying $RESOURCE_COUNT resources to cluster..."
        kubectl apply -f /tmp/manifests.yaml
        
        # Wait for the target deployment to be ready
        echo ""
        echo "⏳ Waiting for $TARGET_DEPLOYMENT rollout to complete..."
        if kubectl rollout status deployment/$TARGET_DEPLOYMENT -n ${{ env.NAMESPACE }} --timeout=300s; then
          echo "✅ Rollout completed successfully!"
        else
          echo "❌ Rollout failed or timed out"
          echo "📋 Pod status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=$TARGET_DEPLOYMENT
          exit 1
        fi
        
        # Switch traffic to new deployment
        echo ""
        echo "🔀 Switching service traffic to $TARGET_DEPLOYMENT..."
        kubectl patch svc easyshop-service -n ${{ env.NAMESPACE }} \
          -p '{"spec":{"selector":{"app":"'$TARGET_DEPLOYMENT'"}}}'
        
        # Scale down the old deployment
        if [ "$CURRENT_DEPLOYMENT" != "$TARGET_DEPLOYMENT" ]; then
          echo ""
          echo "📉 Scaling down old deployment: $CURRENT_DEPLOYMENT"
          kubectl scale deployment/$CURRENT_DEPLOYMENT --replicas=0 -n ${{ env.NAMESPACE }} || echo "⚠️  Old deployment not found or already scaled"
        fi
        
        echo ""
        echo "🎉 Blue-Green Deployment Completed Successfully!"
        echo "=============================================="
        echo "🎯 Active Deployment: $TARGET_DEPLOYMENT"
        echo "📊 Resources Applied: $RESOURCE_COUNT"
        echo "🐋 Image: ${{ env.IMAGE_WITH_DIGEST }}"
#====================================================================
#====================================================================

    - name: 🔍 Verify Deployment
      run: |
        echo "🔍 Verifying deployment..."
        
        # Check pods
        echo "📦 Pods in ${{ env.NAMESPACE }}:"
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Check services
        echo "🌐 Services in ${{ env.NAMESPACE }}:"
        kubectl get svc -n ${{ env.NAMESPACE }}
        
        # Get the actual hostname from ingress
        echo "🔗 Ingress in ${{ env.NAMESPACE }}:"
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        INGRESS_HOST=$(kubectl get ingress easyshop-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "${{ secrets.TF_DNS_ZONE_NAME }}")
        echo "INGRESS_HOST=$INGRESS_HOST" >> $GITHUB_ENV

    - name: 📋 Deployment Summary
      run: |
        echo "🎉 Blue-Green Deployment Complete!"
        echo "=================================="
        echo "🏷️  SHA Version: ${{ env.VERSION }}"
        echo "🐋 Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}"
        echo "📌 Digest: ${{ env.IMAGE_WITH_DIGEST }}"
        echo "🎯 Cluster: ${{ env.AKS_CLUSTER_NAME }}"
        echo "🏠 Namespace: ${{ env.NAMESPACE }}"
        echo "🌐 URL: https://${{ env.INGRESS_HOST }}"
        echo "📍 Commit: ${{ github.sha }}"
        echo ""
        echo "🔄 Blue-Green Strategy:"
        echo "  ✅ Deployed to inactive slot with digest pinning"
        echo "  ✅ Verified health and readiness probes"
        echo "  ✅ Switched traffic with zero downtime"
        echo "  ✅ Scaled down old deployment"
        echo "=================================="
name: EasyShop Application Deployment

on:
  workflow_dispatch:
  repository_dispatch:
    types: [deploy-applications]
  workflow_run:
    workflows: ["Terraform Infrastructure Provisioning"]
    types: [completed]
    branches: [main]

env:
  REGISTRY: ${{ secrets.TF_ACR_NAME }}.azurecr.io
  IMAGE_NAME: easyshop
  AKS_CLUSTER_NAME: ${{ secrets.TF_AKS_CLUSTER_NAME }}
  RESOURCE_GROUP: ${{ secrets.TF_PROJECT_NAME }}-rg
  NAMESPACE: easyshop

jobs:
  deploy-application:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'repository_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    
    steps:
    - name: üöÄ Checkout Repository
      uses: actions/checkout@v4

    - name: üîê Azure Login
      uses: azure/login@v2
      with:
        creds: |
          {
            "clientId": "${{ secrets.ARM_CLIENT_ID }}",
            "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.ARM_TENANT_ID }}"
          }

    - name: üéØ Generate SHA Version
      id: version
      run: |
        VERSION="${GITHUB_SHA::8}"
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "üì¶ Using SHA version: $VERSION"

    # ‚úÖ FIXED: Set up Docker Buildx with container driver that supports cache
    - name: üêã Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        driver-opts: |
          image=moby/buildkit:latest
        use: true

    # ‚úÖ FIXED: Use Azure CLI for ACR login (more reliable than docker-login action)
    - name: üîë Login to ACR
      run: |
        az acr login --name ${{ secrets.TF_ACR_NAME }}

    # ‚úÖ FIXED: Build and Push with ACR registry cache (more reliable than GHA cache for ACR)
    # Modify your existing build step to capture the digest:
    # Modify your existing build step to capture the digest:
    - name: üèóÔ∏è Build and Push with Caching
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        build-args: |
          GIT_SHA=${{ env.VERSION }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache,mode=max
        outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push=true

    # Then extract the digest from the build output:
    - name: üìå Get Image Digest from Build
      run: |
        # The build step outputs metadata including the digest
        IMAGE_DIGEST="${{ steps.build.outputs.digest }}"
        
        if [[ -n "$IMAGE_DIGEST" ]]; then
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          echo "‚úÖ Got digest from build: $IMAGE_DIGEST"
        else
          # Fallback: extract from build metadata
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}"
          echo "‚ö†Ô∏è No digest from build, using tag: $IMAGE_WITH_DIGEST"
        fi
        
        echo "IMAGE_WITH_DIGEST=$IMAGE_WITH_DIGEST" >> $GITHUB_ENV
        echo "üìå Final image: $IMAGE_WITH_DIGEST"

    - name: ‚öôÔ∏è Connect to AKS & Install Kustomize
      run: |
        echo "üîë Getting AKS credentials..."
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
        
        echo "üì¶ Installing kustomize..."
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/

    - name: üöÄ Blue-Green Deployment
      run: |
        set -e  # Exit on any error
        
        echo "üöÄ Starting Blue-Green Deployment with Enhanced Debugging..."
        
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        cd kubernetes
        
        # ==========================================
        # PHASE 1: FILE VALIDATION
        # ==========================================
        echo "üìã Phase 1: Validating individual YAML files..."
        failed_files=()
        
        for file in *.yaml *.yml; do
          if [[ -f "$file" ]]; then
            echo -n "  Testing $file... "
            if kubectl --dry-run=client apply -f "$file" &>/tmp/file-test.log; then
              echo "‚úÖ"
            else
              echo "‚ùå"
              failed_files+=("$file")
              echo "    Error in $file:"
              head -3 /tmp/file-test.log | sed 's/^/      /'
            fi
          fi
        done
        
        if [[ ${#failed_files[@]} -gt 0 ]]; then
          echo "üö® FAILED FILES: ${failed_files[*]}"
          echo "‚ùå Cannot proceed with invalid YAML files!"
          exit 1
        fi
        
        echo "‚úÖ All individual files are valid YAML"
        
        # ==========================================
        # PHASE 2: KUSTOMIZATION SYNTAX CHECK
        # ==========================================
        echo ""
        echo "üìù Phase 2: Checking kustomization.yaml syntax..."
        
        # Check if kustomization.yaml is valid YAML
        if ! yq eval '.' kustomization.yaml >/dev/null 2>/tmp/yaml-check.log; then
          echo "‚ùå kustomization.yaml is not valid YAML:"
          cat /tmp/yaml-check.log
          exit 1
        fi
        
        echo "‚úÖ kustomization.yaml is valid YAML"
        
        # Check for encoding issues
        if file kustomization.yaml | grep -q "with BOM"; then
          echo "‚ö†Ô∏è  kustomization.yaml has BOM - removing..."
          sed -i '1s/^\xEF\xBB\xBF//' kustomization.yaml
        fi
        
        if grep -q $'\r' kustomization.yaml; then
          echo "‚ö†Ô∏è  kustomization.yaml has CRLF - converting to LF..."
          sed -i 's/\r$//' kustomization.yaml
        fi
        
        # ==========================================
        # PHASE 3: INCREMENTAL RESOURCE TESTING
        # ==========================================
        echo ""
        echo "üîç Phase 3: Testing resources incrementally..."
        
        # Create minimal test kustomization
        cat > kustomization-debug.yaml << 'EOF'
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        namespace: easyshop
        resources: []
        EOF
        
        # Resources in order of dependency
        test_resources=(
          "01-namespace.yaml"
          "00-priority-class.yaml" 
          "04-configmap.yaml"
          "05-secrets.yaml"
          "15-keyvault-secret-provider.yaml"
          "06-mongodb-service.yaml"
          "07-mongodb-statefulset.yaml"
          "13-redis-service.yaml"
          "14-redis-deployment.yaml"
          "08a-blue-deployment.yml"
          "08b-green-deployment.yaml"
          "09-easyshop-service.yaml"
          "11-hpa.yaml"
          "12-migration-job.yaml"
          "10-ingress.yaml"
          "cert-manager-issuer.yaml"
          "easyshop-certificate.yaml"
        )
        
        total_resources=0
        for resource in "${test_resources[@]}"; do
          if [[ -f "$resource" ]]; then
            echo -n "  Adding $resource... "
            
            # Add resource to test kustomization
            yq eval ".resources += [\"$resource\"]" kustomization-debug.yaml -i
            
            # Test build
            if kustomize build kustomization-debug.yaml > /tmp/incremental-test.yaml 2>/tmp/incremental-error.log; then
              new_count=$(grep -c "^kind:" /tmp/incremental-test.yaml 2>/dev/null || echo "0")
              echo "‚úÖ (total: $new_count resources)"
              total_resources=$new_count
            else
              echo "‚ùå THIS RESOURCE BREAKS KUSTOMIZE!"
              echo "      Error details:"
              cat /tmp/incremental-error.log | head -5 | sed 's/^/        /'
              echo ""
              echo "      Resource preview:"
              head -15 "$resource" | sed 's/^/        /'
              echo ""
              echo "üö® CULPRIT FOUND: $resource"
              exit 1
            fi
          else
            echo "  ‚ö†Ô∏è  $resource - file not found, skipping"
          fi
        done
        
        echo ""
        echo "üìä Incremental test result: $total_resources total resources"
        
        # ==========================================
        # PHASE 4: FULL KUSTOMIZATION TEST
        # ==========================================
        echo ""
        echo "üîç Phase 4: Testing full kustomization..."
        
        # Show current kustomization content
        echo "üìù Current kustomization.yaml content:"
        echo "----------------------------------------"
        cat kustomization.yaml
        echo "----------------------------------------"
        
        # Update image first
        echo ""
        echo "üìù Updating image to: ${{ env.IMAGE_WITH_DIGEST }}"
        kustomize edit set image gibranf/easyshop=${{ env.IMAGE_WITH_DIGEST }}
        
        # Test full build with verbose output
        echo ""
        echo "üîç Testing full kustomize build..."
        if ! kustomize build --load-restrictor LoadRestrictionsNone . > /tmp/full-build.yaml 2>/tmp/full-error.log; then
          echo "‚ùå FULL BUILD FAILED!"
          echo "Error details:"
          cat /tmp/full-error.log
          echo ""
          echo "Kustomization after image update:"
          cat kustomization.yaml
          exit 1
        fi
        
        # Count final resources
        final_count=$(grep -c "^kind:" /tmp/full-build.yaml 2>/dev/null || echo "0")
        yaml_docs=$(grep -c "^---" /tmp/full-build.yaml 2>/dev/null || echo "0")
        
        echo "üìä Full build results:"
        echo "  - Kubernetes resources (kind:): $final_count"
        echo "  - YAML documents (---): $yaml_docs"
        echo "  - Total file size: $(wc -c < /tmp/full-build.yaml) bytes"
        
        if [[ $final_count -eq 0 ]]; then
          echo ""
          echo "‚ùå ZERO RESOURCES GENERATED!"
          echo "üîç Debug information:"
          echo "  - Build output size: $(wc -l < /tmp/full-build.yaml) lines"
          echo "  - First 50 lines of build output:"
          head -50 /tmp/full-build.yaml | sed 's/^/    /'
          echo ""
          echo "  - Kustomization.yaml structure check:"
          yq eval '.' kustomization.yaml | head -20 | sed 's/^/    /'
          exit 1
        fi
        
        echo "‚úÖ Kustomize build successful: $final_count resources generated"
        
        # ==========================================
        # PHASE 5: DEPLOYMENT EXECUTION
        # ==========================================
        echo ""
        echo "üöÄ Phase 5: Executing deployment..."
        
        # Determine target deployment
        CURRENT_DEPLOYMENT=$(kubectl get svc easyshop-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.app}' 2>/dev/null || echo "easyshop-blue")
        
        if [[ "$CURRENT_DEPLOYMENT" == "easyshop-blue" ]]; then
          TARGET_DEPLOYMENT="easyshop-green"
          echo "üîÑ Switching from BLUE to GREEN"
        else
          TARGET_DEPLOYMENT="easyshop-blue"  
          echo "üîÑ Switching from GREEN to BLUE"
        fi
        
        # Apply manifests
        echo "üì¶ Applying manifests..."
        if ! kustomize build . | kubectl apply -f - 2>/tmp/apply-error.log; then
          echo "‚ùå KUBECTL APPLY FAILED!"
          echo "Apply error details:"
          cat /tmp/apply-error.log
          echo ""
          echo "What we tried to apply:"
          kustomize build . | head -100
          exit 1
        fi
        
        echo "‚úÖ Manifests applied successfully"
        
        # Wait for deployment
        echo "‚è≥ Waiting for $TARGET_DEPLOYMENT to be ready..."
        if ! kubectl rollout status deployment/$TARGET_DEPLOYMENT -n ${{ env.NAMESPACE }} --timeout=300s; then
          echo "‚ùå DEPLOYMENT ROLLOUT FAILED!"
          echo "Pod status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=$TARGET_DEPLOYMENT
          echo "Pod descriptions:"
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=$TARGET_DEPLOYMENT | head -100
          echo "Pod logs:"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=$TARGET_DEPLOYMENT --tail=100 || echo "No logs available"
          exit 1
        fi
        
        # Switch service
        echo "üîÄ Switching service to $TARGET_DEPLOYMENT..."
        kubectl patch svc easyshop-service -n ${{ env.NAMESPACE }} \
          -p '{"spec":{"selector":{"app":"'$TARGET_DEPLOYMENT'"}}}'
        
        # Scale down old deployment
        if [[ "$CURRENT_DEPLOYMENT" != "$TARGET_DEPLOYMENT" ]]; then
          echo "üìâ Scaling down old deployment: $CURRENT_DEPLOYMENT"
          kubectl scale deployment/$CURRENT_DEPLOYMENT --replicas=0 -n ${{ env.NAMESPACE }}
        fi
        
        # Cleanup debug files
        rm -f kustomization-debug.yaml /tmp/file-test.log /tmp/yaml-check.log /tmp/incremental-test.yaml /tmp/incremental-error.log /tmp/full-build.yaml /tmp/full-error.log /tmp/apply-error.log
        
        echo ""
        echo "‚úÖ BLUE-GREEN DEPLOYMENT COMPLETED SUCCESSFULLY!"
        echo "üéØ Active deployment: $TARGET_DEPLOYMENT"
        echo "üìä Total resources deployed: $final_count"

    - name: üîç Verify Deployment
      run: |
        echo "üîç Verifying deployment..."
        
        # Check pods
        echo "üì¶ Pods in ${{ env.NAMESPACE }}:"
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Check services
        echo "üåê Services in ${{ env.NAMESPACE }}:"
        kubectl get svc -n ${{ env.NAMESPACE }}
        
        # Get the actual hostname from ingress
        echo "üîó Ingress in ${{ env.NAMESPACE }}:"
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        INGRESS_HOST=$(kubectl get ingress easyshop-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "${{ secrets.TF_DNS_ZONE_NAME }}")
        echo "INGRESS_HOST=$INGRESS_HOST" >> $GITHUB_ENV

    - name: üìã Deployment Summary
      run: |
        echo "üéâ Blue-Green Deployment Complete!"
        echo "=================================="
        echo "üè∑Ô∏è  SHA Version: ${{ env.VERSION }}"
        echo "üêã Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.VERSION }}"
        echo "üìå Digest: ${{ env.IMAGE_WITH_DIGEST }}"
        echo "üéØ Cluster: ${{ env.AKS_CLUSTER_NAME }}"
        echo "üè† Namespace: ${{ env.NAMESPACE }}"
        echo "üåê URL: https://${{ env.INGRESS_HOST }}"
        echo "üìç Commit: ${{ github.sha }}"
        echo ""
        echo "üîÑ Blue-Green Strategy:"
        echo "  ‚úÖ Deployed to inactive slot with digest pinning"
        echo "  ‚úÖ Verified health and readiness probes"
        echo "  ‚úÖ Switched traffic with zero downtime"
        echo "  ‚úÖ Scaled down old deployment"
        echo "=================================="